# Tricore_TC1.6.2

# 卷二指令集使用手册
* 32位微控制器

## 0.相关约定

### 0.1 进制

* 十六进制后缀"H"
* 八进制后缀"B"

### 0.2 寄存器重置
* 寄存器重置值一般不由体系结构定义，但体系结构会给定实现中启动时设置的值
* 如果需要在体系结构中定义重置值，会在文档中会显示
* 如果文档当中不显示，则不定义重置值

### 0.3 寄存器使用
* 寄存器位使用通常使用"寄存器的名字.位名"，例如：PSW.IS表示PSW寄存器的中断堆栈控制位

### 0.4 相关单位缩写
速度相关
* MHz = 兆赫兹
* KBaud, kBit = 1,000字符/位每秒
* MBaud, MBit = 1,000,000字符/位每秒
* KByte = 1024 bytes
* MByte = 1048576 bytes每秒
* GByte = 1024 兆字节

数据格式相关
* Byte = 8 bit
* Half-word = 16 bit
* Word = 32 bit
* Double-word = 64 bit

### 0.5 位类型缩写
* r: 只读位
* w: 只写位
* rw: 可读写位
* h: 可由硬件修改位，可以与"rw"或"r"一同使用，例如："rwh"或"rh"
* -: 保留位，读取值未定义，但必须被写为0

## 1.卷二第一章指令集信息介绍

### 1.1 指令语法
* 指令操作数用逗号分隔。

#### 1.1.1 操作数定义
由于是32位处理器，所以数据寄存器和地址寄存器都是32位

* D[n]：数据寄存器n
* A[n]：地址寄存器n
* E[n]：扩展数据寄存器n，包含64位数据使用小端存储，其中：E[n][63:32] = D[n+1][31:0]，E[n][31:0] = D[n][31:0]
* dispn："n"位的位移值，用于在分支指令中形成有效地址
* constn："n"位常量值，作为一个操作数
* offn："n"位偏移值，用于在加载和存储指令中形成有效地址
* pos1,pos2：用于指定位字段指令中的位置
* pos：位置用于和位字段宽度一起定义一个字段
* width：指定位字段的宽度

#### 1.1.2 指令助记符
（1）三部分组成
* 基础操作：指定指令操作，例如：ADD 表示加法，J 表示跳转，LD 表示内存加载；使用多个指令操作，例如：OR.EQ， 其中用点号分割。
* 操作修饰符：更精确的指令操作，例如：ADDI 表示使用立即数进行加法；多个操作修饰符，例如：ADDIH
* 操作数修饰符：提供源操作数的数据类型。例如：ADD.B 表示字节加法，JZ.A 表示使用地址寄存器的跳转，LD.H 表示半字加载。数据类型修饰符由句点 （.） 分隔。

（2）例子：ADDS.U指令介绍
* "ADD"为基本操作
* "S"为操作修饰符，表示得到的结果是饱和的
* "U"为操作数修饰符，表示操作数是无符号的
* 注意：典型的16位指令，使用GPR寄存器作为隐式的源或目的操作数

（3）隐式的操作数定义
* D[15]：许多16位指令的隐式数据寄存器
* A[10]：栈寄存器SP
* A[11]：CALL,JL,JLA和JLI指令的返回值寄存器RA，以及中断中返回PC值
* A[15]：许多16位加载/存储指令的隐式地址寄存器

#### 1.1.3 操作修饰符
当指令中出现多个后缀时，助记符中的出现顺序与此表中的顺序相同：

| 操作修饰符 | 名称     | 描述                | 例子     |
| -------     | ---      | ----                | ----     | 
| C           | Carry      | 使用和更新PSW的进位 | ADDC     |
| I           | Immediate    | 大立即数            | ADDI      |
| H           | High word      | 立即数的值放到最高有效位 | ADDIH |
| S           | Saturation    |  饱和结果       | ADDS    |
| X           | Carry out   | 更新PSW的进位     | ADDX    |
| EQ          | Equal       | 比较相等          | JEQ     |
...

#### 1.1.4 操作数修饰符
当指令中出现多个后缀时，助记符中的出现顺序与此表中的顺序相同：

| 操作数修饰符 | 名称     | 描述                | 例子     |
| -------     | ---      | ----                | ----     | 
| D           | Data     | 32位数据            | MOV.D    |
| D           | Double-word |  64位数据或地址   | LD.D     |
| W           | Word      | 32位数据           | EQ.W     |
| A           | Address   | 32位地址            | ADD.A    |
| Q           | Q Format  | 16位有符号分数（Q 格式） | MADD.Q |
| H           | Half-word | 16位数据或两个打包半字节 | ADD.H |
| B           | Byte      | 8位数据或四个打包字节 | ADD.B    |
| T           | Bit       | 1位数据              | AND.T    |
| U           | Unsigned  | 无符号数据类型       | ADDS.U    |

注：Q格式被用于有符号半字乘法器


### 1.2 操作码格式
#### 1.2.1 16位操作码格式
注：16位操作码中op1字段的Bit[0]总是0

#### 1.2.2 32位操作码格式
注：32位操作码中op1字段的Bit[0]总是1

#### 1.2.3 操作字段定义

### 1.3 指令操作语法
每个指令被RTL描述

注：
* 以0位开头，并且是在字中是最低有效位
* 除非另有说明，否则假定所有中间“结果”值都具有无限精度。

#### 1.3.1 RTL函数

#### 1.3.2 缓存RTL函数

#### 1.3.3 浮点运算语法

### 1.4 协处理器指令

### 1.5 PSW状态位（用户状态位）
给定指令描述的“状态”部分列出了可能受操作影响的五个状态标志

注意：
* 在下表中，32 位指令的“结果”为 D[c]。对于 16 位指令，它是 D[a] 或 D[15]（隐式时）。
* PSW 寄存器在第 1 卷“核心寄存器”中定义。

| 字段        | PSW Bit    | 类型  | 描述                             |
| -------     | ---        | ---- | ----                             | 
| C           | 31         | rw   | 进位标志，有进位则PSW.C = 1，否则PSW.C = 0  |
| V           | 30         | rw   | 溢出标志位，结果将超过最大或最小有符号或无符号值（视情况而定）。如果（溢出）则为 PSW.V = 1 其他 PSW.V = 0; |
| SV          | 29         | rw   | 栈溢出标志位，内存溢出，如果（溢出），则 PSW.SV = 1 否则 PSW.SV = PSW.SV; |
| AV          | 28         | rw   | 进阶溢出位，如果（进阶溢出），则 PSW.AV = 1 否则 PSW.AV = 0; |
| SAV         | 27         | rw   | 进阶栈溢出位，如果（进阶溢出），则 PSW.SAV = 1 否则 PSW.SAV = PSW.SAV; |

*  编程说明：V（溢出）和 AV（高级溢出）状态位，由于TriCore指令集包含许多复合指令（MULR，MAC，ABSDIF），因此有必要了解何时计算溢出标志。AV 和 V 标志在最终操作时计算，但饱和指令除外，当它始终在饱和之前时。饱和度本身不是操作的一部分，而是溢出情况的结果（由用户选择）。


### 1.6 操作系统和I/O特权指令列表

| 内核                               |  User-1          | User-0         |
| ---                                | ---               | ---            |
| BISR、MTCR、CACHEI.I、CACHEA.I、RFM | ENABLE、DISABLE、RESTORE | 所有其他的并且包含DEBUG

## 2.卷二指令集概览
本章概述了TriCore指令集架构（ISA）。描述了每种指令类型的基本属性和用法，并描述了16位（短）指令的选择和使用。

### 2.1 整数算术
* 移动
* 加法和减法
* 乘法和乘法加
* 除法
* 绝对值和绝对差
* 最小、最大和饱和
* 条件算术指令
* 逻辑
* 前导0、1和符号计算
* 左右移
* 位段抽取和插入

#### 2.1.1 Move移动
* 将**数据寄存器的值**或**指令中的一个常量值**移动到**目标数据寄存器**中，能够快速加载大的常量数据到一个数据寄存器中
* 使用MOV可将一个16位常量带符号扩展到32位
* 使用MOV.U将一个16位常量0扩展到32位
* 使用MOVH指令将一个16位常量放入16位的高有效位，剩下16位的低有效位用0填充，用于左对齐常数的分数
* 加载一个32位的常量有MOVH指令以及紧跟其后的ADDI指令完成，或者一个MOV.U和紧跟其后的ADDIH指令完成。



## 3.卷二指令集